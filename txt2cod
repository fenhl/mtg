#!/usr/bin/env ruby -I.

require "magic_xml"
require 'trollop'

class Deck
  attr_accessor :name, :comment, :empty_line_starts_sideboard
  def initialize
    @main = Hash.new(0)
    @side = Hash.new(0)
    @in_sideboard = false
    @empty_line_starts_sideboard = false
    @name = ""
    @comment = ""
  end

  def add_card!(name, number, sideboard=@in_sideboard)
    # Common differences between cards.xml
    # and what people type in their decklists online
    name = name.dup
    name.gsub!("’", "'")
    name.gsub!("Æ", "AE")
    name.gsub!(/\AAether/, "AEther")
    name.gsub!(%r[\s*(/+|&)\s*], " // ")
    # Strip expansion name if any
    name.sub!(/\A\[[A-Z0-9]+\]\s+/, "")
    if sideboard
      @side[name] += number
    else
      @main[name] += number
    end
  end

  def process_comment!(comment)
    debug! "Unrecognized comment: #{comment}"
  end

  def parse_line!(line)
    line = line.strip
    case line
    when /\ASB:\s*(\d+)\s*(.*)\z/
      add_card! $2, $1.to_i, true
    when /\A(\d+)\s*(.*)\z/
      add_card! $2, $1.to_i
    when /\ASideboard:?/i
      @in_sideboard = true
    when ""
      @in_sideboard = true if empty_line_starts_sideboard
    when /\A\/\/(.*)/
      process_comment! $1
    else
      debug! "Unrecognized line: #{line}"
    end
  end

  def parse!(input)
    input.each do |line|
      parse_line! line.chomp
    end
  end

  def each_main_card(&blk)
    @main.to_a.sort.each(&blk)
  end

  def each_side_card(&blk)
    @side.to_a.sort.each(&blk)
  end

  def zone_to_xml(zone, name)
    xml(:zone, name: name) do
      zone.to_a.sort.each do |name, count|
        card! number: count, price: 0, name: name
      end
    end
  end

  def to_cod
    out = xml(:cockatrice_deck)
    out << (deckname = xml(:deckname))
    out << (comments = xml(:comments))
    out << zone_to_xml(@main, :main)
    out << zone_to_xml(@side, :side)
    out.add_pretty_printing!
    # Don't prettyprint within these
    deckname << @name
    comments << @comment
    out
  end
end

def debug!(msg)
  STDERR.puts(msg) if $debug
end

opts = Trollop::options do
  opt :name, "Deck name", type: :string, default: "Unknown"
  opt :comment, "Comment", type: :string, defaul: ""
  opt :input, "input (default STDIN)", type: :string
  opt :output, "output (default STDOUT)", type: :string
  opt :dailymtg, "use format from DailyMTG (sideboard indicated by empty line)", type: :boolean, default: false
  opt :verbose, "print warnings for weird input", type: :boolean, default: false
end

$debug = opts[:verbose]
deck = Deck.new
deck.empty_line_starts_sideboard = opts[:dailymtg]
deck.name = opts[:name]
deck.comment = opts[:comment]
deck.parse!(opts[:input] ? File.readlines(opts[:input]) : STDIN.readlines)
if opts[:output]
  File.open(opts[:output], 'w') do |fh|
    fh.puts deck.to_cod
  end
else
  puts deck.to_cod
end
