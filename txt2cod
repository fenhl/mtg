#!/usr/bin/env ruby -I.

require "trollop"
require "cockatrice"

class TextDeckParser
  attr_accessor :empty_line_starts_sideboard, :verbose
  attr_reader :deck
  def initialize
    @deck = Deck.new
    @in_sideboard = false
    @verbose = false
    @empty_line_starts_sideboard = false
  end

  def debug!(msg)
    STDERR.puts(msg) if @verbose
  end

  def process_comment!(comment)
    case comment
    when /\ANAME\s*:\s*(.*)/
      deck.name = $1
    else
      debug! "Unrecognized comment: #{comment}"
    end
  end

  def parse_line!(line)
    line = line.strip
    case line
    when /\ASB:\s*(\d+)\s*(.*)\z/
      deck.add_card! $2, $1.to_i, true
    when /\A(\d+)\s*(.*)\z/
      deck.add_card! $2, $1.to_i, @in_sideboard
    when /\ASideboard:?/i
      @in_sideboard = true
    when ""
      @in_sideboard = true if empty_line_starts_sideboard
    when /\A\/\/(.*)/
      process_comment! $1.strip
    else
      debug! "Unrecognized line: #{line}"
    end
  end

  def parse!(input)
    input.each do |line|
      parse_line! line.chomp
    end
  end
end

opts = Trollop::options do
  opt :name, "Deck name", type: :string, default: "Unknown"
  opt :comment, "Comment", type: :string, defaul: ""
  opt :input, "input (default STDIN)", type: :string
  opt :output, "output (default STDOUT)", type: :string
  opt :dailymtg, "use format from DailyMTG (sideboard indicated by empty line)", type: :boolean, default: false
  opt :verbose, "print warnings for weird input", type: :boolean, default: false
end

parser = TextDeckParser.new
parser.empty_line_starts_sideboard = opts[:dailymtg]
parser.verbose = opts[:verbose]
parser.parse!(opts[:input] ? File.readlines(opts[:input]) : STDIN.readlines)
parser.deck.name = opts[:name] if opts[:name]
parser.deck.comment = opts[:comment] if opts[:comment]

if opts[:output]
  parser.deck.save_as!(opts[:output])
else
  parser.deck.print!
end
